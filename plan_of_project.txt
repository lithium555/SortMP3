Предварительный план по пету:

1) Первичная доработка базы:
1.1) Foreing keys (FK), связать ИД между таблицами.
    http://www.postgresqltutorial.com/postgresql-foreign-key/
    https://postgrespro.ru/docs/postgresql/9.5/ddl-constraints

    https://dba.stackexchange.com/questions/46410/how-do-i-insert-a-row-which-contains-a-foreign-key


1.2) Обработчики ошибок. Разобраться как отличить типы ошибок: "нет записи", "конфликт по уникальному полю", "неверный FK".

2) Поиск дубликатов по хешу
2.1) Хеширование. Разобраться как считать хеш всего файла. Какие хеши сейчас используют и почему.
2.2) Поиск дулей по хешу. Попробовать поменять имя песни в файле и посмотреть найдет ли он дубль.

3) Поиск по акустическим хешам
3.1) Акустический хеш. Зачем нужен? Почему работает лучше чем хеш по файлу? Добавить акустические хеши в базу запуская chromaprint через консоль из Го программы.
3.2) Поиск по акустическим хешам.

4) Интеграция с MusicBrainz
4.1) Поиск по базе MiscBrainz (HTTP API) через акустический хеш. Дополнение тегов в БД.
4.2) Дополнение тегов в файлах (из БД).

5) Интеграция с WikiData
5.1) Поиск по WikiData с помощью идентификаторов MusicBrainz.
5.2) Дополнение тегов из WikiData.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

>>>>>>>> лучше сначала продумай как объекты вообще связаны забывая что там есть папки
>>>>>>>> то есть какие у них связи в реальном мире

>>>>>>>>в идеале опиши это как CREATE TABLE, но пока без FOREIGN KEY
>>>>>>>>так будет точно понятно что ты имеешь в виду
Я перенес всю переписку (там не много) в текстовый файл.
Следующий шаг  это ответиь на твой вопрос :
 >>>>>>>> лучше сначала продумай как объекты вообще связаны забывая что там есть папки
>>>>>>>> то есть какие у них связи в реальном мире

Как я это понял: в реальном мире конечная таблица должна быть такая :
 genre | Name of Singer | album Name | Name of composition
Чтобы ее получить надо понять кто по иерархии от кого зависит :
Песня зависит от альбома,
альбом зависит от автора,  песня зависит от жанра.
Так же песня завиист от автора
Получаем такую типа диаграмму:
Song -> Album
Song -> Author
Song -> Genre

Album -> Author
Это можно представить, как 4 маленьких таблички:

Жанр:
GENRE
------------------
id
name


Автор:

AUTHOR
_______________
id
author_name


Альбом:

ALBUM
_______________
id
authorID
album_name
year (дата выхода альбома),
cover (ссылка или путь к картинке альбома)



Песня:

SONG
-------------------
id
name
albumID
genreID
authorID
trackNum (номер песни в альбоме)


Так же я понял как пофиксить регистр, когда оодна и та ж епесня может попадать с большой и маленькой буквы в названии.
Надо все имена песен исполнителей и так далее опускать в нижний регистр. Так мы обеспечим уникальность для каждой песни и не будет повторов.
А вот что дальше я пока не знаю.
Пока погуглю как создать пакет с postgreSQL и добавлю его в проект.


ID3 теги:
https://en.wikipedia.org/wiki/ID3
либы:
https://github.com/mikkyang/id3-go
или
https://github.com/dhowden/tag


Про почему мало инфы - можно поставить тот же Picard и сравнить с тем что он видит.
Может просто в файле мало всего записано.
https://picard.musicbrainz.org/

https://github.com/mikkyang/id3-go
https://github.com/dhowden/tag


https://stackoverflow.com/questions/24712463/go-there-is-no-parameter-1


Да, в остальных тоже. Postgres по умолчанию ставить значения полям если ты их не
указал. Если это SERIAL, то он генерит новый ключ. Если есть DEFAULT в
объявлении таблицы - использует его. И если нет ни того ни другого,
то поле будет NULL.
